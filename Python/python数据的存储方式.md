## 先从对象引用说起
```python
a = [1, 2, ['aaa', 'bbb']]
b = [1, 2, ['aaa', 'bbb']]
a is b
False

a[0] is b[0]
True

a = b
a is b
True
```
从两个`is`的判断，可以看出，a和b分别引用一个list对象的时候，他们实际指向的不是同一个对象，因为python中的组合数据类型也是对象，list这个数据组合类型在上面的示例中单独声明两次表示两个不同的对象。

但是在list里面，相同的值python在内存中只会创建一个，所以`a[0]和b[0]`引用的是同一个对象，这里虽然看到的是不同的值放在list里面，但是对python而言，他们都是对象引用。同理list是一个对象，`a[2] is b[2]`的结果会是False。

问题：`a = b`这个操作其实在实际应用中，会导致对a的修改都会改变b，这是在操作组合数据类型的时候会经常遇到的问题。

## copy和deepcopy
- copy是一个浅拷贝
- deepcopy，看名字就知道是深拷贝

如果不是组合数据类型，如list里面还有list之类的，那么这两个用法是一致的。copy会把list a里面的对象引用给到b这个list对象，但是他们自己本身是两个对立的list对象，所以`a is b`还是不成立的，但是的每个对象引用是指向同一个对象，**这里就是和深拷贝不同的地方了**，如下的例子：
```python
import copy
a = [1, 2, ['aaa', 'bbb']]
b = copy.copy(a)
a[2][0] = 'a'
```
复制之后我们是不想a/b之间有修改上的关联的，但是因为他们引用了同一个对象，所以结果可能和我们想象的是不一致的，`b[2][0]`的值也是`a`，那么这类组合数据类型在copy的时候，如果希望子列表或其他子结构的值不受影响，要使用`deepcopy`。

这样看来就回到了第一个例子，a和b分开赋值两个list的情况，deepcopy是正确的打开方式。
